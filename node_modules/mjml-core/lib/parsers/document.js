'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _Error = require('../Error');

var _compact = require('lodash/compact');

var _compact2 = _interopRequireDefault(_compact);

var _dom = require('../helpers/dom');

var _dom2 = _interopRequireDefault(_dom);

var _each = require('lodash/each');

var _each2 = _interopRequireDefault(_each);

var _toArray = require('lodash/toArray');

var _toArray2 = _interopRequireDefault(_toArray);

var _filter = require('lodash/filter');

var _filter2 = _interopRequireDefault(_filter);

var _MJMLElementsCollection = require('../MJMLElementsCollection');

var _MJMLHead = require('../MJMLHead');

var _MJMLHead2 = _interopRequireDefault(_MJMLHead);

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var regexTag = function regexTag(tag) {
  return new RegExp('<' + tag + '([^>]*)>([^]*?)</' + tag + '>', 'gmi');
};

/**
 * Avoid htmlparser to parse ending tags
 */
var safeEndingTags = function safeEndingTags(content) {
  var regexpBody = regexTag('mj-body');
  var safeContent = content.replace('$', '&#36;');

  var bodyContent = safeContent.match(regexpBody);

  if (!bodyContent) {
    return safeContent;
  }

  bodyContent = bodyContent[0];

  _MJMLElementsCollection.endingTags.forEach(function (tag) {
    bodyContent = bodyContent.replace(regexTag(tag), _dom2.default.replaceContentByCdata(tag));
  });

  return safeContent.replace(regexpBody, bodyContent);
};

/**
 * converts MJML body into a JSON representation
 */
var mjmlElementParser = function mjmlElementParser(elem, content) {
  if (!elem) {
    throw new _Error.NullElementError('Null element found in mjmlElementParser');
  }

  var findLine = content.substr(0, elem.startIndex).match(/\n/g);
  var lineNumber = findLine ? findLine.length + 1 : 1;
  var tagName = elem.tagName.toLowerCase();
  var attributes = _dom2.default.getAttributes(elem);

  var element = { tagName: tagName, attributes: attributes, lineNumber: lineNumber };

  if (_MJMLElementsCollection.endingTags.indexOf(tagName) !== -1) {
    var $local = _dom2.default.parseXML(elem);
    element.content = $local(tagName).html().trim();
  } else {
    var children = _dom2.default.getChildren(elem);
    element.children = children ? (0, _compact2.default)((0, _filter2.default)(children, function (child) {
      return child.tagName;
    }).map(function (child) {
      return mjmlElementParser(child, content);
    })) : [];
  }

  return element;
};

var parseHead = function parseHead(head, attributes) {
  var $container = _dom2.default.parseHTML(attributes.container);

  (0, _each2.default)((0, _compact2.default)((0, _filter2.default)(_dom2.default.getChildren(head), function (child) {
    return child.tagName;
  })), function (el) {
    var element = {
      attributes: _dom2.default.getAttributes(el),
      children: (0, _toArray2.default)(el.childNodes),
      tagName: el.tagName.toLowerCase()
    };

    var handler = _MJMLHead2.default[element.tagName];

    if (handler) {
      handler(element, _extends({ $container: $container }, attributes));
    } else {
      (0, _warning2.default)(false, 'No handler found for: ' + element.tagName + ', in mj-head, skipping it');
    }
  });

  attributes.container = _dom2.default.getHTML($container);
};

/**
 * Import an html document containing some mjml
 * returns JSON
 *   - container: the mjml container
 *   - mjml: a json representation of the mjml
 */
var documentParser = function documentParser(content, attributes) {
  var safeContent = safeEndingTags(content);

  var body = void 0;
  var head = void 0;

  try {
    var $ = _dom2.default.parseXML(safeContent);

    body = $('mjml > mj-body');
    head = $('mjml > mj-head');

    if (body.length > 0) {
      body = body.children().get(0);
    }
  } catch (e) {
    throw new _Error.ParseError('Error while parsing the file');
  }

  if (!body || body.length < 1) {
    throw new _Error.EmptyMJMLError('No root "<mjml>" or "<mj-body>" found in the file, or "<mj-body>" is empty');
  }

  if (head && head.length === 1) {
    parseHead(head.get(0), attributes);
  }

  return mjmlElementParser(body, safeContent);
};

exports.default = documentParser;